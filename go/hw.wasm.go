// Code generated by wasm.go. DO NOT EDIT.

package main

import (
	gobin "encoding/binary"
	"fmt"
	"math"
	"math/bits"

	"wasm.go/binary"
	"wasm.go/instance"
	"wasm.go/interpreter"
)

var LE = gobin.LittleEndian

type aotModule struct {
	importedFuncs []instance.Function
	table         instance.Table
	memory        instance.Memory
	globals       []instance.Global
}

// TODO
func dummy() {
	_ = bits.Add
	_ = binary.Decode
	_ = interpreter.New
}

func Instantiate(mm instance.Map) (instance.Module, error) {
	m := &aotModule{
		importedFuncs: make([]instance.Function, 1),
		globals:       make([]instance.Global, 2),
	}
	m.importedFuncs[0] = mm["env"].GetMember("print_char").(instance.Function) // (i32)->()
	m.memory = interpreter.NewMemory(1, 1)
	m.globals[0] = interpreter.NewGlobal(127, false, 0)
	m.globals[1] = interpreter.NewGlobal(127, false, 14)
	m.initMem()
	return m, nil // TODO
}

func (m *aotModule) initMem() {
	m.memory.Write(0, []byte("Hello, World!\n"))
}

// env.print_char (i32)->()
func (m *aotModule) f0(a0 uint64) {
	_, err := m.importedFuncs[0].Call(int32(a0))
	if err != nil {} // TODO
}

// ()->()
func (m *aotModule) f1() {
	// no locals
	var s0, s1 uint64 // stack

{ // _l0_0
	s0 = m.globals[0].GetAsU64() // global.get 0
	s1 = m.globals[1].GetAsU64() // global.get 1
	m.f2(s0, s1) // call func#2
} // end of _l0_0
}

// (i32,i32)->()
func (m *aotModule) f2(a0, a1 uint64) {
	var a2 uint64 // locals
	var s0, s1 uint64 // stack

{ // _l0_0
	_l1_0: for {
		s0 = a0 // local.get 0
		s1 = a2 // local.get 2
		s0 = uint64(uint32(s0) + uint32(s1)) // i32.add
		s0 = uint64(m.readU8(0 + s0)) // i32.load8_u
		m.f0(s0) // call func#0
		s0 = a2 // local.get 2
		s1 = 0x1 // i32.const 1
		s0 = uint64(uint32(s0) + uint32(s1)) // i32.add
		a2 = s0 // local.set 2
		s0 = a2 // local.get 2
		s1 = a1 // local.get 1
		s0 = b2i(uint32(s0) < uint32(s1)) // i32.lt_u
		if s0 != 0 { continue _l1_0 } // br_if 0
		break _l1_0
	} // end of _l1_0
} // end of _l0_0
}

// main ()->()
func (m *aotModule) exported0(args []interface{}) ([]interface{}, error) {
	m.f1()
	return nil, nil
}

// print_str (i32,i32)->()
func (m *aotModule) exported1(args []interface{}) ([]interface{}, error) {
	m.f2(uint64(args[0].(int32)), uint64(args[1].(int32)))
	return nil, nil
}

// instance.Instance
func (m *aotModule) GetMember(name string) interface{} {
	panic("TODO")
}
func (m *aotModule) GetGlobalVal(name string) (interface{}, error) {
	panic("TODO")
}
func (m *aotModule) SetGlobalVal(name string, val interface{}) error {
	panic("TODO")
}
func (m *aotModule) InvokeFunc(name string, args ...interface{}) ([]interface{}, error) {
	switch name {
	case "main": return m.exported0(args)
	case "print_str": return m.exported1(args)
	default: return nil, fmt.Errorf("func not found: %s", name)
	}
}

// memory read
func (m *aotModule) readU8(offset uint64) byte {
	var buf [1]byte
	m.memory.Read(offset, buf[:])
	return buf[0]
}
func (m *aotModule) readU16(offset uint64) uint16 {
	var buf [2]byte
	m.memory.Read(offset, buf[:])
	return LE.Uint16(buf[:])
}
func (m *aotModule) readU32(offset uint64) uint32 {
	var buf [4]byte
	m.memory.Read(offset, buf[:])
	return LE.Uint32(buf[:])
}
func (m *aotModule) readU64(offset uint64) uint64 {
	var buf [8]byte
	m.memory.Read(offset, buf[:])
	return LE.Uint64(buf[:])
}

// memory write
func (m *aotModule) writeU8(offset uint64, n byte) {
	var buf [1]byte
	buf[0] = n
	m.memory.Write(offset, buf[:])
}
func (m *aotModule) writeU16(offset uint64, n uint16) {
	var buf [2]byte
	LE.PutUint16(buf[:], n)
	m.memory.Write(offset, buf[:])
}
func (m *aotModule) writeU32(offset uint64, n uint32) {
	var buf [4]byte
	LE.PutUint32(buf[:], n)
	m.memory.Write(offset, buf[:])
}
func (m *aotModule) writeU64(offset uint64, n uint64) {
	var buf [8]byte
	LE.PutUint64(buf[:], n)
	m.memory.Write(offset, buf[:])
}

// utils
func b2i(b bool) uint64 { if b { return 1 } else { return 0 } }
func _f32(i uint64) float32 { return math.Float32frombits(uint32(i)) }
func _u32(f float32) uint64 { return uint64(math.Float32bits(f)) }
func _f64(i uint64) float64 { return math.Float64frombits(i) }
func _u64(f float64) uint64 { return math.Float64bits(f) }

